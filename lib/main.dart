// main.dart
//
// Packages: flutter_reactive_ble, flutter_ble_peripheral, uuid, firebase_core, firebase_auth
// Permissions: BLE as in previous example.

import 'dart:async';
import 'dart:convert';
import 'dart:io' show Platform;
import 'dart:typed_data';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/material.dart';
import 'package:flutter_ble_peripheral/flutter_ble_peripheral.dart';
import 'package:flutter_reactive_ble/flutter_reactive_ble.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:uuid/uuid.dart' as uuid_gen;

// --- FIREBASE IMPORTS ---
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'firebase_options.dart'; // Generated by flutterfire configure
import 'login_page.dart';       // Your new login page

Future<bool> requestBlePermissions() async {
  try {
    if (Platform.isIOS) {
      // On iOS foreground advertising/scanning usually only needs Bluetooth.
      final btStatus = await Permission.bluetooth.status;
      if (!btStatus.isGranted) {
        final req = await Permission.bluetooth.request();
        if (!req.isGranted) return false;
      }
      // Location optional for classic foreground BLE scanning; ignore if denied.
      return true;
    }

    // ANDROID
    final androidInfo = await DeviceInfoPlugin().androidInfo;
    final sdk = androidInfo.version.sdkInt;

    // Build required permissions based on SDK
    List<Permission> required = [];
    List<Permission> optional = [];

    if (sdk >= 31) {
      // Android 12+ granular Bluetooth permissions
      required = [
        Permission.bluetoothScan,
        Permission.bluetoothConnect,
        Permission.bluetoothAdvertise, // needed because you advertise
      ];
      // Location is optional if you declared SCAN with neverForLocation and do not need location features
      optional = [Permission.location];
    } else if (sdk >= 29) {
      // Android 10–11: Location required for BLE scans
      required = [Permission.location];
      // Legacy Bluetooth permissions are normal (granted at install), no runtime request
    } else {
      // Android 9 and below: coarse/fine location (permission_handler maps both to location)
      required = [Permission.location];
    }

    // Request only missing required permissions
    final toRequest = <Permission>[
      for (final p in required)
        if (!(await p.status).isGranted) p,
    ];
    if (toRequest.isNotEmpty) {
      await toRequest.request();
    }

    final allRequiredGranted = await _allGranted(required);

    if (!allRequiredGranted) {
      // If something critical (required) denied -> fail
      return false;
    }

    // Optionally try requesting optional (ignored in result)
    for (final p in optional) {
      final st = await p.status;
      if (!st.isGranted && !st.isPermanentlyDenied) {
        await p.request();
      }
    }

    return true;
  } catch (e) {
    debugPrint('Permission check error: $e');
    // Fail open only if you already have at least scan/connect granted (best effort)
    return true;
  }
}

Future<bool> _allGranted(List<Permission> perms) async {
  for (final p in perms) {
    final st = await p.status;
    if (!st.isGranted) return false;
  }
  return true;
}

final _ble = FlutterReactiveBle();
final _peripheral = FlutterBlePeripheral();
final _uuidGen = uuid_gen.Uuid();

final Uuid serviceUuid = Uuid.parse("12345678-1234-5678-1234-56789abcdef0");
const String TARGET_CLASS_ID = "CLS25";

// --- MODIFIED main() FUNCTION ---
Future<void> main() async {
  // Ensure Flutter is initialized
  WidgetsFlutterBinding.ensureInitialized();
  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const MyApp());
}

// --- MODIFIED MyApp WIDGET ---
class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'BLE Attendance',
      home: AuthGate(), // Use a gate to check authentication state
    );
  }
}

// --- NEW AuthGate WIDGET ---
class AuthGate extends StatelessWidget {
  const AuthGate({super.key});

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<User?>(
      stream: FirebaseAuth.instance.authStateChanges(),
      builder: (context, snapshot) {
        // Show a loading indicator while checking auth state
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Scaffold(
            body: Center(child: CircularProgressIndicator()),
          );
        }

        // If user is logged in, show the role selection screen
        if (snapshot.hasData) {
          return const RoleSelectionScreen();
        }

        // Otherwise, show the login page
        return const LoginPage();
      },
    );
  }
}


// --- MODIFIED RoleSelectionScreen WIDGET ---
class RoleSelectionScreen extends StatefulWidget {
  const RoleSelectionScreen({super.key});

  @override
  State<RoleSelectionScreen> createState() => _RoleSelectionScreenState();
}

class _RoleSelectionScreenState extends State<RoleSelectionScreen> {
  String? _userName;
  bool _isLoading = true;
  bool _isTeacher = false;  // Track if user is a teacher

  @override
  void initState() {
    super.initState();
    _fetchUserInfo();
  }

  Future<void> _fetchUserInfo() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;

    try {
      // Try to find user in teachers collection
      final teacherDoc = await FirebaseFirestore.instance
          .collection('teacher')
          .where('email', isEqualTo: user.email)
          .get();

      if (teacherDoc.docs.isNotEmpty) {
        setState(() {
          _userName = teacherDoc.docs.first.get('name') as String;
          _isTeacher = true;
          _isLoading = false;
        });
        return;
      }

      // If not found in teachers, try students collection
      final studentDoc = await FirebaseFirestore.instance
          .collection('student')
          .where('email', isEqualTo: user.email)
          .get();

      if (studentDoc.docs.isNotEmpty) {
        setState(() {
          _userName = studentDoc.docs.first.get('name') as String;
          _isTeacher = false;
          _isLoading = false;
        });
        return;
      }

      setState(() => _isLoading = false);
    } catch (e) {
      debugPrint('Error fetching user info: $e');
      setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(_isTeacher ? 'Teacher Dashboard' : 'Student Dashboard'),
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            tooltip: 'Logout',
            onPressed: () async {
              await FirebaseAuth.instance.signOut();
            },
          ),
        ],
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Center(
            child: _isLoading
                ? const CircularProgressIndicator()
                : _userName == null
                    ? const Text('No user information found')
                    : Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Text(
                            'Welcome, $_userName',
                            style: Theme.of(context).textTheme.titleLarge,
                          ),
                          const SizedBox(height: 24),
                          if (_isTeacher)
                            ElevatedButton.icon(
                              onPressed: () => Navigator.push(
                                context,
                                MaterialPageRoute(builder: (_) => const TeacherScreen()),
                              ),
                              icon: const Icon(Icons.qr_code_scanner),
                              label: const Text("Start Scanning"),
                              style: ElevatedButton.styleFrom(
                                padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
                              ),
                            )
                          else
                            ElevatedButton.icon(
                              onPressed: () => Navigator.push(
                                context,
                                MaterialPageRoute(builder: (_) => const StudentScreen()),
                              ),
                              icon: const Icon(Icons.bluetooth_connected),
                              label: const Text("Start Advertising"),
                              style: ElevatedButton.styleFrom(
                                padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
                              ),
                            ),
                        ],
                      ),
          ),
        ),
      ),
    );
  }
}

// ======================= TEACHER =======================
class TeacherScreen extends StatefulWidget {
  const TeacherScreen({super.key});
  @override
  State<TeacherScreen> createState() => _TeacherScreenState();
}

class _TeacherScreenState extends State<TeacherScreen> {
  StreamSubscription<DiscoveredDevice>? _scanSub;
  final Map<String, DiscoveredDevice> _devices = {};
  final Map<String, ParsedAdvertisement> _advInfo = {};
  final Set<String> _verifiedIds = {};
  bool _scanning = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      bool granted = await requestBlePermissions();
      if (granted) {
        _startScanning();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('BLE permissions are required to scan devices.'),
          ),
        );
      }
    });
  }

  void _startScanning() {
    _scanSub?.cancel();
    setState(() {
      _devices.clear();
      _advInfo.clear();
      _verifiedIds.clear();
      _scanning = true;
    });

    _scanSub = _ble
        .scanForDevices(withServices: [], scanMode: ScanMode.lowLatency)
        .listen(
          (device) {
            debugPrint(
              '🔹 Found device: ${device.name}, id: ${device.id}, manufacturerData: ${device.manufacturerData}',
            );
            final adv = ParsedAdvertisement.fromDiscoveredDevice(device);
            if (adv.rawManufacturerString == null) {
              // Not our frame → ignore
              return;
            }
            _devices[device.id] = device;
            _advInfo[device.id] = adv;

            // Automatically verify if class ID matches
            if (adv.classId == TARGET_CLASS_ID) {
              _verifiedIds.add(device.id);
            }

            setState(() {});
          },
          onError: (e) {
            debugPrint('Scan error: $e');
            setState(() => _scanning = false);
          },
        );
  }

  void _stopScanning() async {
    await _scanSub?.cancel();
    _scanSub = null;
    setState(() => _scanning = false);
  }

  @override
  void dispose() {
    _scanSub?.cancel();
    super.dispose();
  }

  Widget _deviceTile(DiscoveredDevice d) {
    final id = d.id;
    final parsed = _advInfo[id];
    final displayName =
        parsed?.displayName ?? (d.name.isNotEmpty ? d.name : '(unnamed)');
    final classId = parsed?.classId ?? '-';
    final manufStr = parsed?.rawManufacturerString ?? '';

    return ListTile(
      title: Text(displayName),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('id: $id'),
          Text('class: $classId'),
          if (manufStr.isNotEmpty)
            Text('adv: $manufStr', overflow: TextOverflow.ellipsis),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final deviceList = _devices.values.toList()
      ..sort((a, b) => (b.rssi ?? 0).compareTo(a.rssi ?? 0));

    final verifiedList = deviceList
        .where((d) => _verifiedIds.contains(d.id))
        .toList();

    return Scaffold(
      appBar: AppBar(title: const Text('Teacher — Scanning')),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(8),
            child: Wrap(
              spacing: 8,
              children: [
                ElevatedButton(
                  onPressed: _scanning ? null : _startScanning,
                  child: const Text('Start Scan'),
                ),
                ElevatedButton(
                  onPressed: _scanning ? _stopScanning : null,
                  child: const Text('Stop Scan'),
                ),
                Text('Discovered: ${deviceList.length}'),
                Text('Verified: ${_verifiedIds.length}'),
              ],
            ),
          ),
          const Divider(),
          // Verified Students List
          if (verifiedList.isNotEmpty)
            Padding(
              padding: const EdgeInsets.all(8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    '✅ Verified Students',
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  ...verifiedList.map((d) {
                    final adv = _advInfo[d.id]!;
                    return ListTile(
                      title: Text(adv.displayName ?? d.name),
                      subtitle: Text('id:${d.id}, class:${adv.classId}'),
                      leading: const Icon(
                        Icons.check_circle,
                        color: Colors.green,
                      ),
                    );
                  }).toList(),
                  const Divider(),
                ],
              ),
            ),
          Expanded(
            child: ListView.separated(
              itemCount: deviceList.length,
              separatorBuilder: (_, __) => const Divider(height: 1),
              itemBuilder: (ctx, i) {
                final d = deviceList[i];
                // final adv = _advInfo[d.id]!;
                // Skip showing verified devices in main list (already in top list)
                if (_verifiedIds.contains(d.id)) return const SizedBox.shrink();
                return _deviceTile(d);
              },
            ),
          ),
        ],
      ),
    );
  }
}

// ======================= STUDENT =======================
class StudentScreen extends StatefulWidget {
  const StudentScreen({super.key});
  @override
  State<StudentScreen> createState() => _StudentScreenState();
}

class _StudentScreenState extends State<StudentScreen> {
  // Controllers to display the fetched information in the UI
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _idController = TextEditingController();

  bool _isLoading = true;
  bool _advertising = false;
  String _currentStrategy = '';

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      await _fetchStudentInfo();
      bool granted = await requestBlePermissions();
      if (granted && mounted) {
        await _checkDeviceCapability();
      }
    });
  }

  /// Fetches student's name and roll number from Firestore.
  Future<void> _fetchStudentInfo() async {
    setState(() => _isLoading = true);
    final user = FirebaseAuth.instance.currentUser;

    if (user == null || user.email == null) {
      setState(() => _isLoading = false);
      return;
    }

    try {
      final studentQuery = await FirebaseFirestore.instance
          .collection('student')
          .where('email', isEqualTo: user.email)
          .limit(1)
          .get();

      if (studentQuery.docs.isNotEmpty) {
        final studentData = studentQuery.docs.first.data();
        setState(() {
          _nameController.text = studentData['name'] as String? ?? 'N/A';
          _idController.text = studentData['id'] as String? ?? 'N/A';
        });
      }
    } catch (e) {
      debugPrint('Error fetching student info: $e');
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  Future<void> _checkDeviceCapability() async {
    try {
      final isSupported = await _peripheral.isSupported;
      debugPrint('📱 Device BLE advertising support: $isSupported');

      if (!isSupported && mounted) {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('BLE Advertising Not Supported'),
            content: const Text(
                'This device reports that it does not support BLE advertising. We will attempt to start it anyway.'),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('OK'),
              ),
            ],
          ),
        );
      }
    } catch (e) {
      debugPrint('❌ Error checking BLE capability: $e');
    }
  }

  Future<void> _startAdvertising() async {
    if (_advertising) return;

    final studentId = _idController.text.trim();
    if (studentId.isEmpty || studentId == 'N/A') {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Cannot advertise without a valid ID.')),
        );
      }
      return;
    }

    setState(() {
      _advertising = true;
      _currentStrategy = 'Starting...';
    });

    try {
      final payload = 'ATS:$studentId';
      final bytes = Uint8List.fromList(utf8.encode(payload));

      // Simplest possible advertising packet
      final advertiseData = AdvertiseData(
        manufacturerId: 0x004C, // Apple's ID, often works as a default
        manufacturerData: bytes,
      );

      await _peripheral.stop();
      await _peripheral.start(advertiseData: advertiseData);

      debugPrint('✅ Advertising started successfully.');
      if (mounted) {
        setState(() {
          _currentStrategy = 'Manufacturer Data';
        });
      }
    } catch (e) {
      debugPrint('❌ Failed to start advertising: $e');
      if (mounted) {
        setState(() {
          _advertising = false;
          _currentStrategy = 'Failed';
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to start advertising: $e')),
        );
      }
    }
  }

  Future<void> _stopAdvertising() async {
    try {
      await _peripheral.stop();
      debugPrint('⏹️ Advertising stopped.');
    } catch (e) {
      debugPrint('Stop advertise error: $e');
    } finally {
      if (mounted) {
        setState(() {
          _advertising = false;
          _currentStrategy = '';
        });
      }
    }
  }

  @override
  void dispose() {
    _stopAdvertising();
    _nameController.dispose();
    _idController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Student — Advertising')),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Padding(
              padding: const EdgeInsets.all(12),
              child: Column(
                children: [
                  TextField(
                    controller: _nameController,
                    readOnly: true,
                    decoration: const InputDecoration(labelText: 'Your name'),
                  ),
                  const SizedBox(height: 8),
                  TextField(
                    controller: _idController,
                    readOnly: true,
                    decoration: const InputDecoration(labelText: 'Your ID (from Firebase)'),
                  ),
                  const SizedBox(height: 12),
                  Row(
                    children: [
                      ElevatedButton(
                        onPressed: _advertising ? null : _startAdvertising,
                        child: Text(
                          _advertising ? 'Advertising...' : 'Start Advertising',
                        ),
                      ),
                      const SizedBox(width: 8),
                      ElevatedButton(
                        onPressed: _advertising ? _stopAdvertising : null,
                        child: const Text('Stop Advertising / Verified'),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  // This text now shows the original display format
                  Text(
                    'Advertising payload: ATS:${_idController.text}',
                  ),
                  const SizedBox(height: 12),
                ],
              ),
            ),
    );
  }
}

const String kPrimaryServiceUuidStr   = "0000180a-0000-1000-8000-00805f9b34fb";
const String kServiceDataUuidStr      = "0000180a-0000-1000-8000-00805f9b34fd";

final Uuid kPrimaryServiceUuid  = Uuid.parse(kPrimaryServiceUuidStr);
final Uuid kServiceDataUuid     = Uuid.parse(kServiceDataUuidStr);
// Helper class to parse BLE advertisement
class ParsedAdvertisement {
  final String? rawManufacturerString;
  final String? classId;
  final String? displayName;
  final String? studentId; // <— new

  ParsedAdvertisement({
    this.rawManufacturerString,
    this.classId,
    this.displayName,
    this.studentId,
  });

  static ParsedAdvertisement fromDiscoveredDevice(DiscoveredDevice d) {
    String? raw;
    String? classId;
    String? name;
    String? sid;
    Uint8List? dataBytes;

    // --- NEW: Check manufacturerData first ---
    // The student app is advertising with manufacturerData. The raw bytes are in
    // d.manufacturerData. The first 2 bytes are the manufacturer ID, and the
    // rest is the payload.
    if (d.manufacturerData.isNotEmpty && d.manufacturerData.length > 2) {
      // We skip the first 2 bytes (the manufacturer ID) to get the payload.
      dataBytes = d.manufacturerData.sublist(2);
    }

    // --- FALLBACK: Check serviceData if manufacturerData is empty or fails ---
    if (dataBytes == null && d.serviceData.isNotEmpty) {
      if (d.serviceData.containsKey(kServiceDataUuid)) {
        dataBytes = d.serviceData[kServiceDataUuid];
      } else if (d.serviceData.containsKey(kPrimaryServiceUuid)) {
        dataBytes = d.serviceData[kPrimaryServiceUuid];
      } else {
        // Fallback to any service data that looks like ours
        for (final entry in d.serviceData.entries) {
          try {
            final test = utf8.decode(entry.value, allowMalformed: true).trim();
            if (test.startsWith('ATS:')) {
              dataBytes = entry.value;
              break;
            }
          } catch (_) {}
        }
      }
    }

    if (dataBytes != null) {
      try {
        final decoded = utf8.decode(dataBytes, allowMalformed: true).trim();
        debugPrint('🔍 Decoded advertisement data: $decoded');
        if (decoded.startsWith('ATS:')) {
          raw = decoded;
          final body = decoded.substring(4);
          final parts = body.split('|');
          if (parts.isNotEmpty) {
            // The first part is now treated as the student ID
            sid = parts.first;
            classId = parts.first; // Also assign to classId for compatibility
          }
          if (parts.length > 1) name = parts[1];
        }
      } catch (e) {
        debugPrint('⚠️ Error decoding advertisement data: $e');
      }
    }

    return ParsedAdvertisement(
      rawManufacturerString: raw,
      classId: classId, // For backward compatibility with UI
      displayName: name ?? d.name,
      studentId: sid,
    );
  }
}